[
["index.html", "Introducción a R Prólogo", " Introducción a R Diego J. Lizcano 2020-04-15 Prólogo Este libro es una pequeña guía y tutorial sobre como emplear el lenguaje estadistico R Este libro ha sido escrito en R-Markdown empleando el paquete bookdown Este libro está disponible en el repositorio Github: dlizcano/IntroR. Esta obra está bajo una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional. "],
["intro.html", "Capítulo 1 Introducción 1.1 Requisitos 1.2 Primeros pasos", " Capítulo 1 Introducción Este libro es una pequeña guía para la aprender los elementos basicos de la estructura y programación de R. R es un entorno y lenguaje de programación basado en objetos y enfocado en análisis estadístico y de datos. Vale la pena revisar su historia y evolución en la [pagina de wikipedia](https://es.wikipedia.org/wiki/R_(lenguaje_de_programación). A lo largo del libro se presentarán códigos que el lector puede copiar y pegar en su consola de R para obtener los mismos resultados aquí del libro. Los códigos se destacan en una caja de color similar a la mostrada a continuación. # R como calculadora 4 + 6 # mi primer objeto a &lt;- c(1, 5, 6) # una operación con el objeto 5 * a # una secuencia 1:10 Los resultados o salidas obtenidos de cualquier código se destacan con dos símbolos de númeral (##) al inicio de cada línea o renglón, esto quiere decir que todo lo que inicie con ## son resultados obtenidos y NO los debe copiar. Abajo se muestran los resultados obtenidos luego de correr el código anterior. El usuario habitual de R no hace programación propiamente dicha, sino que utiliza R iterativa e interactivamente: ensaya, se equivoca y vuelve a probar. Solo cuando termina el ciclo y el resultado es satisfactorio, produce un resultado final. Que, usualmente, no es un programa para ejecutar sino, un reporte de resultados o un informe. A diferencia de otros lenguajes de programación como Python, en R existen muchas y tal vez demasiadas maneras alternativas de hacer las cosas y eso es considerado como un problema por un programador. Y es un problema muy desconcertante para el principiante de R. No obstante, por motivos pedagógicos, el libro tratará de presentar una de las formas de resolver un determinado problema: la que el autor consideró más natural. 1.1 Requisitos Disponer de una versión reciente de R y RStudio. Descargar la última versión. Instalar el paquete tidyverse, el cual reune varios paquetes útiles de R: # stable version on CRAN install.packages(&quot;tidyverse&quot;) # or development version on GitHub # devtools::install_github(&#39;rstudio/bookdown&#39;) 1.2 Primeros pasos Si se emplea RStudio (recomendado), lo más cómodo sería crear un proyecto nuevo mediante el menú File &gt; New Project &gt; New Directory &gt; proyecto1. Si se abre el proyecto en RStudio, se puede compilar empleando el boton Build Book1 en la pestaña Build. Por defecto se generará el libro (en los distintos formatos) en la carpeta _book y al terminar se abrirá automáticamente la versión HTML. El libro se generará (de forma simultánea en los formatos deseados) a partir de una serie de documentos R Markdown, cada uno correspondiente a un capítulo. Nota: Si se produce un error, puede ser necesario2 eliminar manualmente los ficheros de salida (e.g. book_filename.Rmd o book_filename.md) para poder volver a compilar. Alternativamente se puede ejecutar la función render_book() en el directorio del proyecto.↩ "],
["creando-objetos-simples.html", "Capítulo 2 Creando objetos simples 2.1 Vectores 2.2 Operaciones basicas con vectores 2.3 Inspeccionando vectores", " Capítulo 2 Creando objetos simples En R los objetos son la clave. 2.1 Vectores Los vectores son colecciones de objetos de un solo tipo. La foma mas facil de crear un vector es escribir lo que estará dentro. # usando la funcion concatenar value_num1 &lt;- c(3,4,2,6,20) value_num2 &lt;- c(5,10,15,20,25,30,35,50) value_char &lt;- c(&quot;koala&quot;,&quot;kangaroo&quot;,&quot;echidna&quot;) logical_1 &lt;- c(F,F,T,T) logical_2 &lt;- c(FALSE,FALSE,TRUE,TRUE) vec_num &lt;- 1:15 c(1:5,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) # note como los numeros se convierten a texto (encerrado entre comillas) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; # concatenar dos vectores en uno solo new_vec &lt;- c(value_num1, value_num2) Otra forma es usar funciones como rep y seq # Creating Vectors: rep and seq functions value &lt;- rep(5,10) value ## [1] 5 5 5 5 5 5 5 5 5 5 seq(from=2,to=10,by=2) ## [1] 2 4 6 8 10 seq(from=2,to=10,length=5) ## [1] 2 4 6 8 10 2.2 Operaciones basicas con vectores # Basic computation with numerical vectors x &lt;- rnorm(100) # extrae 100 valores al azar de la distribucion normal y_exp &lt;- 2^x + 1 # exponencial y_cua &lt;- x^2 + 1 # cuadratica # grafiquemos plot(x,y_exp) #graficar con y_cua Figura 2.1: figura de una curva exponencial. z &lt;- (x-mean(x))/sd(x) # see also &#39;scale&#39; mean(z) # la media ## [1] -7.705425e-18 sd(y_exp) # la desviacióm ## [1] 1.045863 2.3 Inspeccionando vectores Las siguientes funciones, sirven para inspeccionar el contenido de un vector: length(x) table(x) # ¡muy importante! Cuenta cuantos valores de cada numero summary(y) head(x) tail(x) Para seleccionar elementos de un vector se usa el corchete []. Pero, a diferencia de lo que ocurre con las tablas, como los vectores son objetos unidimensionales, no se usa coma. Obviamente, el corchete sigue admitiendo no solo los índices de los elementos que se quieren extraer, sino que además permite utilizar condiciones lógicas. x[1:33] x[c(1,3)] x[x &gt; 1.5] x[3:1] x[-(1:2)] x[-length(x)] "],
["matrices.html", "Capítulo 3 Matrices", " Capítulo 3 Matrices Las matrices son el sigiente paso luego de los vectores. Las matrices son muy útiles en calculos algebraicos. ################### # Creating Matrices: dim and matrix functions value &lt;- rnorm(12) dim(value) &lt;- c(4,3) value ## [,1] [,2] [,3] ## [1,] 2.09356357 0.3701367 0.7560182 ## [2,] -0.05328767 0.2915016 1.5062623 ## [3,] -0.91091678 0.5890649 -1.9146872 ## [4,] -0.14271843 -0.5997559 -0.3705862 dim(value) &lt;- NULL matrix(value,2,3) ## [,1] [,2] [,3] ## [1,] 2.09356357 -0.9109168 0.3701367 ## [2,] -0.05328767 -0.1427184 0.2915016 matrix(value,2,3,byrow=T) ## [,1] [,2] [,3] ## [1,] 2.0935636 -0.05328767 -0.9109168 ## [2,] -0.1427184 0.37013667 0.2915016 # Creating Matrices: rbind and cbind functions value &lt;- matrix(rnorm(6),2,3,byrow=T) value2 &lt;- rbind(value,c(1,1,2)) value2 ## [,1] [,2] [,3] ## [1,] 0.1532493 -0.004299827 0.5573862 ## [2,] 0.4544363 0.269015447 1.0018636 ## [3,] 1.0000000 1.000000000 2.0000000 value3 &lt;- cbind(value2,c(1,1,2)) "],
["tablas.html", "Capítulo 4 Tablas 4.1 Crear Data Frames 4.2 Indexar data frames 4.3 Crear una columna nueva 4.4 visualizar la tabla graficamente", " Capítulo 4 Tablas Las tablas en R se conocen como Data Frames. Muy frecuentemente, los datos se disponen en tablas: las hojas de cálculo, las bases de datos, los ficheros csv, etc. contienen, esencialmente, tablas. Además, casi todos los métodos estadísticos (p.e., la regresión lineal) operan sobre información organizada en tablas. Como consecuencia, gran parte del día a día del trabajo con R consiste en manipular tablas de datos para darles el formato necesario para acabar analizándolos estadística o gráficamente. Las hojas de cálculo son herramientas que prácticamente todos hemos usado para manipular tablas de datos. Sin embargo R y R studio no permiten la flexibilidad de manejar tablas con el mouse. Asi que hay que aprender algunos comandos basicos para manipular e indexar. 4.1 Crear Data Frames Para practicar y como ejemplo, usaremos una tabla que viene por defecto con R. Se trata de la tabla iris3. Esta tiene columnas que contienen cuatro características métricas de cada especie de flor: la longitud y la anchura de sus pétalos y sépalos; y la especie: setosa, versicolor o virgínica, a la que pertenecen. De momento y hasta que aprendamos cómo importar datos de fuentes externas, utilizaremos este y otros conjuntos de datos de ejemplo que incluye R. Ya que es impráctico mostrar tablas enteras en la consola, sobre todo cuando son grandes. Para mostrar solo parte de ellas, hay algunas funciones útiles para inspeccionar tablas (y, como veremos más adelante, no solo tablas), esta son: str (iris) # &quot;representación textual&quot; del objeto class (iris) # &quot;representación de la clase&quot; del objeto head (iris) # primeras seis filas tail (iris) # últimas seis filas dim (iris) # filas x columnas colnames (iris) # nombre de sus columnas summary (iris) # resumen estadístico de las columnas 4.2 Indexar data frames Las tablas se indexan usando el corchete [] y este debe ir separado por una coma [,] donde el primer valor representa las filas y el segundo las columnas, siempre en ese orden. Por ejemplo: iris[1:5,] # muestra las 5 primeras filas iris[,1:3] # muestra las 3 primeras columnas iris[25,4] # muestra el dato de la fila 25 y columna 4 # los corchetes tambien admiten los nombres de las columnas iris[, &quot;Species&quot;] ## Usando el $ en las tablas # Pero se usa mas habitualmente (porque es más rápido y más legible) iris$Species en lugar de iris[, &quot;Species&quot;] iris$Species El corchete también permite seleccionar filas mediante condiciones lógicas. Por ejemplo seleccionemos de la tabla de iris las que corresponden a la especie setosa: iris[iris$Species == &quot;setosa&quot;,] 4.2 Ejercicio: Selecciona las filas de iris cuya longitud del pétalo sea mayor que 4. 4.3 Crear una columna nueva Lo mas practico es usar el nombre de la tabla seguido de $ y el nombre de la nueva columna. Por ejemplo creemos la columna raiz cuadrada de la longitud del petalo iris$raiz_petalo &lt;- sqrt (iris$Petal.Length) # sqrt es la raiz cuadrada. Tengan en cuenta que: agregar una columna que ya existe la reemplaza, agregar una columna que no existe la crea y asignar NULL a una columna existente la elimina. 4.4 visualizar la tabla graficamente 4.4.1 como histograma A veces es mucho más informativa una representación visual de los datos. La manera más rápida (y recomendada) de hacerse una idea de la distribución de los datos de una columna numérica es usando histogramas. En R, para representar el histograma de la columna Sepal.Width de iris se puede hacer: hist(iris$Sepal.Width) #### y para editar el grafico se especifican parametros adicionales hist(iris$Sepal.Width, main = &quot;iris: histograma de la anchura de los sépalos&quot;, xlab = &quot;anchura del sépalo&quot;, ylab = &quot;frecuencia&quot;, col = &quot;steelblue&quot;) 4.4.2 Como dos variables numericas Por ejemplo representemos la lomgitud del sepalo versus el petalo. plot(iris$Sepal.Length, iris$Petal.Length) "],
["representación-de-la-relación-entre-una-variable-continua-y-otra-categórica-diagramas-de-caja-boxplots.html", "Capítulo 5 Representación de la relación entre una variable continua y otra categórica: diagramas de caja (boxplots)", " Capítulo 5 Representación de la relación entre una variable continua y otra categórica: diagramas de caja (boxplots) Los diagramas de cajas (boxplot) estudian la distribución de una variable continua en función de una variable categórica. Están emparentados con los histogramas porque resumen la distribución de una variable continua. Para ello utilizan una representación todavía mas esquemática que la de un histograma: una caja y unos segmentos que acotan las regiones donde la variable continua concentra el grueso de las observaciones. Por ejemplo, podemos estudiar la distribución de la anchura del sépalo en iris en función de la especie usando diagramas de cajas así: boxplot(iris$Sepal.Width ~ iris$Species, col = &quot;gray&quot;, main = &quot;Especies de iris\\nsegún la anchura del sépalo&quot;) La notación y ~ x es muy común en R y significa que vas a hacer algo con y en función de x; en este caso, algo es un diagrama de cajas. Cuando construyamos modelos, querremos entender la variable objetivo y en función de una o más variables predictoras y volveremos a hacer uso de esa notación. "],
["creación-y-e-indexación-de-listas.html", "Capítulo 6 Creación y e indexación de listas", " Capítulo 6 Creación y e indexación de listas Las tablas son contenedores de información estructurada: las columnas son del mismo tipo, todas tienen la misma longitud, etc. Gran parte de los datos con los que se trabaja habitualmente son estructurados, palabra que, en la jerga, significa que admiten una representación tabular. Sin embargo, cada vez es más habitual trabajar directamente con información desestructurada. Particularmente, en ciencia de datos. Eso justifica el uso de las listas, que pueden definirse como contenedores genéricos de información desestructurada. Las listas son objetos muy versatiles que mezclan varias cosas y sirven como contenedores genericos de dstos e informacón. Estas son una ventaja de R, sobre otros lenguajes como Python que no las tienen. Pero pueden llegar a ser objetos complejos dificiles de entender y visualizar. a &lt;- c(1,2,3,4,5,6,7) # vector numerico b &lt;- c(&quot;Casa&quot;, &quot;Carro&quot;, &quot;Beca&quot;) # vector alfanumerico florecitas &lt;- iris[3:25,2:5] #data frame lista1 &lt;- list(a, b, florecitas) las listas disponen de un operador para extraer elementos, los dobles corchetes, [[]], que funcionan de manera parecida y analoga a $. lista1[[2]] # extrae el objeto b ## [1] &quot;Casa&quot; &quot;Carro&quot; &quot;Beca&quot; lista1[[3]] [,4] # extrae la columna 4 del objeto 3 ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa ## Levels: setosa versicolor virginica "],
["creación-de-funciones.html", "Capítulo 7 Creación de Funciones", " Capítulo 7 Creación de Funciones Esta sección, por su importancia, pertenece propiamente a la sección de programación. La creación de funciones en lo que sigue del curso es fundemental y, presenta la gran versatilidad de un lenguaje de programación. Creemos una función que opera sobre un vector que vamos a llamar x media &lt;- function(x){ # inicio de la funcion longitud &lt;- length(x) suma &lt;- sum(x) return (suma / longitud) # devuelve el resultado de la media } # final de la funcion # creemos un vector vector1 &lt;- rnorm (100) # 100 datos al azar de la distribucion normal # apliquemos la funcion al vector media(vector1) ## [1] 0.1600103 "],
["creación-de-bucles.html", "Capítulo 8 Creación de bucles 8.1 Convirtamolo en función", " Capítulo 8 Creación de bucles En la programación en R es habitual construir loops o bucles dentro de los cuales se va modificando el valor de una expresión. Los bucles más habituales en R comienzan con for. Su sintaxis es for (var in vector){ # expresión que se repite } Ejemplo: construyamos un bucle que repite la impresion de un nombre 10 veces for (i in 1:10){ # variable i en un vector de 1 a 10 print (&quot;Carlos&quot;) # expresión que se repite } # final del bucle ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; ## [1] &quot;Carlos&quot; Hagamos un bucle mas interesante que simula datos de pesencia ausencia obtenidos al azar (con probabilidad 0.5) de la distibucion binomial, para un estudio de ocupacion con 15 sitios y cuatro visitas repetidas a cada sitio. sitios &lt;- 15 visitas &lt;- 4 datos &lt;- matrix(NA, 15,4) # matriz vacia donde vamos a poner los datos for (i in 1:sitios){ # variable i en un vector de 1 a 10 y &lt;- rbinom(visitas, 1, 0.5) # 0.5 es la probabilidad datos [i,] &lt;- y } datos ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 1 ## [2,] 1 1 0 1 ## [3,] 1 1 0 1 ## [4,] 1 0 1 1 ## [5,] 1 0 1 0 ## [6,] 0 1 0 1 ## [7,] 0 0 1 0 ## [8,] 1 1 0 0 ## [9,] 1 0 1 1 ## [10,] 0 1 1 1 ## [11,] 1 1 1 1 ## [12,] 0 0 0 0 ## [13,] 1 1 0 0 ## [14,] 1 0 0 0 ## [15,] 0 1 0 0 8 Ejercicio: Crear una matriz de datos simulados, de un estudio donde se cuentan renacuajos en 20 sitios con cinco visitas repetidas a cada sitio. 8.1 Convirtamolo en función genera_datos &lt;- function(sitios=15, visitas=4, probabilidad=0.5) { datos &lt;- matrix(NA, sitios, visitas) # matriz vacia donde vamos a poner los datos for (i in 1:sitios){ # variable i y &lt;- rbinom(visitas, 1, probabilidad) # dados guardados en y datos [i,] &lt;- y # y pasa a la fila i de la tabla de datos } return(datos) # muestra los datos al finalizar el bucle } # llamemos la funcion genera_datos() #con los valores por defecto ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 1 ## [2,] 1 0 0 1 ## [3,] 1 0 1 0 ## [4,] 1 0 0 0 ## [5,] 0 0 1 1 ## [6,] 1 0 0 1 ## [7,] 1 0 0 0 ## [8,] 0 0 0 1 ## [9,] 0 1 1 1 ## [10,] 0 0 0 0 ## [11,] 1 0 0 0 ## [12,] 1 0 0 1 ## [13,] 0 0 0 0 ## [14,] 1 0 0 1 ## [15,] 1 1 0 1 genera_datos(30, 6, 0.5) # con 30 sitios, 6 visitas repetidas y probabilidad 0.5 ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 0 1 0 1 1 1 ## [2,] 1 1 0 0 0 1 ## [3,] 0 1 1 1 0 1 ## [4,] 1 1 0 0 1 0 ## [5,] 1 0 0 1 1 1 ## [6,] 0 1 0 1 0 1 ## [7,] 0 0 0 0 1 1 ## [8,] 1 1 1 1 0 0 ## [9,] 1 1 0 1 0 0 ## [10,] 1 0 0 0 1 1 ## [11,] 0 1 0 1 1 0 ## [12,] 0 0 1 0 0 1 ## [13,] 1 1 1 0 1 1 ## [14,] 0 0 0 0 1 0 ## [15,] 0 0 1 1 0 0 ## [16,] 1 1 1 0 0 0 ## [17,] 1 0 0 0 0 1 ## [18,] 1 1 1 1 1 0 ## [19,] 0 1 1 0 0 0 ## [20,] 1 1 1 0 0 0 ## [21,] 1 0 1 0 0 1 ## [22,] 0 0 0 1 0 1 ## [23,] 1 1 0 0 1 1 ## [24,] 1 0 1 1 0 0 ## [25,] 1 0 1 0 0 1 ## [26,] 0 1 0 1 0 0 ## [27,] 1 1 1 1 1 1 ## [28,] 1 1 1 0 0 0 ## [29,] 0 1 0 1 1 1 ## [30,] 1 0 0 1 0 1 "],
["bibliografía.html", "Bibliografía", " Bibliografía "]
]
